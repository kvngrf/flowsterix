{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "mobile-drawer",
  "type": "registry:component",
  "title": "Mobile Drawer",
  "description": "Mobile-optimized bottom sheet drawer for tour content with swipe gestures, snap points, and safe area support.",
  "dependencies": [
    "@flowsterix/react",
    "motion"
  ],
  "registryDependencies": [
    "https://flowsterix.com/r/tour-provider.json",
    "https://flowsterix.com/r/mobile-drawer-handle.json",
    "https://flowsterix.com/r/tour-controls.json",
    "https://flowsterix.com/r/tour-progress.json"
  ],
  "files": [
    {
      "path": "registry/flowsterix/mobile-drawer.tsx",
      "content": "'use client'\n\nimport { useTour } from '@flowsterix/react'\nimport {\n  AnimatePresence,\n  motion,\n  useAnimationControls,\n  type PanInfo,\n} from 'motion/react'\nimport * as React from 'react'\n\nimport { cn } from '@/lib/utils'\nimport { MobileDrawerHandle } from '@/registry/flowsterix/mobile-drawer-handle'\nimport { TourControls } from '@/registry/flowsterix/tour-controls'\nimport { TourProgress } from '@/registry/flowsterix/tour-progress'\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport type MobileDrawerSnapPoint = 'minimized' | 'peek' | 'expanded'\n\nexport interface MobileDrawerProps {\n  /** Content to render inside the drawer */\n  children: React.ReactNode\n  /** Snap point when drawer opens (default: 'expanded') */\n  defaultSnapPoint?: MobileDrawerSnapPoint\n  /** Available snap points (default: ['minimized', 'expanded']) */\n  snapPoints?: MobileDrawerSnapPoint[]\n  /** Whether user can minimize the drawer (default: true) */\n  allowMinimize?: boolean\n  /** Maximum height as ratio of viewport (default: 0.85) */\n  maxHeightRatio?: number\n  /** Callback when snap point changes */\n  onSnapPointChange?: (point: MobileDrawerSnapPoint) => void\n  /** Additional class names */\n  className?: string\n  /** Controls configuration */\n  controls?: React.ComponentProps<typeof TourControls>\n  /** Progress configuration */\n  progress?: React.ComponentProps<typeof TourProgress> & { show?: boolean }\n  /** Step key for crossfade animation */\n  stepKey?: string\n}\n\n// =============================================================================\n// Constants\n// =============================================================================\n\nconst MINIMIZED_HEIGHT = 100\nconst HANDLE_HEIGHT = 28 // py-3 = 24px + 4px pill\nconst HEADER_HEIGHT = 40 // progress row\nconst CONTROLS_HEIGHT = 72 // controls padding + buttons\nconst CHROME_HEIGHT = HANDLE_HEIGHT + HEADER_HEIGHT + CONTROLS_HEIGHT\nconst PEEK_RATIO = 0.4\nconst DEFAULT_MAX_HEIGHT_RATIO = 0.85\nconst VELOCITY_THRESHOLD = 500\nconst DRAG_ELASTIC = { top: 0.1, bottom: 0.3 }\n\nconst springConfig = {\n  type: 'spring' as const,\n  damping: 30,\n  stiffness: 400,\n}\n\n// =============================================================================\n// Hooks\n// =============================================================================\n\nfunction useSnapPoints({\n  snapPoints,\n  viewportHeight,\n  safeAreaBottom,\n  contentHeight,\n  maxHeightRatio,\n}: {\n  snapPoints: MobileDrawerSnapPoint[]\n  viewportHeight: number\n  safeAreaBottom: number\n  contentHeight: number\n  maxHeightRatio: number\n}) {\n  return React.useMemo(() => {\n    const viewportMax = (viewportHeight - safeAreaBottom) * maxHeightRatio\n    const isMeasured = contentHeight >= 0\n\n    // Before measurement: use small initial height to avoid flicker\n    // After measurement: use content height + chrome, capped at viewport max\n    const initialHeight = MINIMIZED_HEIGHT + 120 // Small initial size\n    const idealExpandedHeight = isMeasured\n      ? contentHeight + CHROME_HEIGHT\n      : initialHeight\n    const expandedHeight = Math.min(\n      Math.max(idealExpandedHeight, MINIMIZED_HEIGHT + 100),\n      viewportMax,\n    )\n\n    const heights: Record<MobileDrawerSnapPoint, number> = {\n      minimized: MINIMIZED_HEIGHT,\n      peek: Math.round(Math.max(expandedHeight * PEEK_RATIO, MINIMIZED_HEIGHT + 50)),\n      expanded: Math.round(expandedHeight),\n    }\n\n    // Filter to only enabled snap points and sort by height\n    const enabled = snapPoints\n      .map((point) => ({ point, height: heights[point] }))\n      .sort((a, b) => a.height - b.height)\n\n    return { heights, enabled, maxHeight: viewportMax, isMeasured }\n  }, [snapPoints, viewportHeight, safeAreaBottom, contentHeight, maxHeightRatio])\n}\n\nfunction useSafeAreaBottom() {\n  const [safeAreaBottom, setSafeAreaBottom] = React.useState(0)\n\n  React.useEffect(() => {\n    const computeSafeArea = () => {\n      const computed = getComputedStyle(document.documentElement)\n      const value = computed.getPropertyValue('--sab') || '0'\n      setSafeAreaBottom(parseInt(value, 10) || 0)\n    }\n\n    // Set CSS variable for safe area\n    document.documentElement.style.setProperty(\n      '--sab',\n      'env(safe-area-inset-bottom, 0px)',\n    )\n\n    // Initial compute after a frame to ensure CSS is applied\n    requestAnimationFrame(computeSafeArea)\n\n    window.addEventListener('resize', computeSafeArea)\n    return () => window.removeEventListener('resize', computeSafeArea)\n  }, [])\n\n  return safeAreaBottom\n}\n\nfunction useViewportHeight() {\n  const [height, setHeight] = React.useState(\n    typeof window !== 'undefined' ? window.innerHeight : 800,\n  )\n\n  React.useEffect(() => {\n    const updateHeight = () => {\n      // Use visualViewport for iOS Safari keyboard handling\n      const vh = window.visualViewport?.height ?? window.innerHeight\n      setHeight(vh)\n    }\n\n    updateHeight()\n\n    window.addEventListener('resize', updateHeight)\n    window.visualViewport?.addEventListener('resize', updateHeight)\n\n    return () => {\n      window.removeEventListener('resize', updateHeight)\n      window.visualViewport?.removeEventListener('resize', updateHeight)\n    }\n  }, [])\n\n  return height\n}\n\nfunction useContentHeight(contentRef: React.RefObject<HTMLDivElement | null>) {\n  // Start with -1 to indicate \"not yet measured\"\n  const [contentHeight, setContentHeight] = React.useState(-1)\n\n  React.useEffect(() => {\n    const element = contentRef.current\n    if (!element) return\n\n    const measure = () => {\n      setContentHeight(element.scrollHeight)\n    }\n\n    // Measure after a frame to ensure content is rendered\n    requestAnimationFrame(measure)\n\n    const observer = new ResizeObserver(measure)\n    observer.observe(element)\n\n    return () => observer.disconnect()\n  }, [contentRef])\n\n  return contentHeight\n}\n\n// =============================================================================\n// Component\n// =============================================================================\n\n/**\n * Mobile-optimized bottom sheet drawer for tour content.\n * Features swipe gestures, snap points, and safe area support.\n *\n * @example\n * ```tsx\n * <MobileDrawer\n *   defaultSnapPoint=\"expanded\"\n *   snapPoints={['minimized', 'expanded']}\n *   onSnapPointChange={(point) => console.log(point)}\n * >\n *   <StepContent />\n * </MobileDrawer>\n * ```\n */\nexport function MobileDrawer({\n  children,\n  defaultSnapPoint = 'expanded',\n  snapPoints: snapPointsProp = ['minimized', 'expanded'],\n  allowMinimize = true,\n  maxHeightRatio = DEFAULT_MAX_HEIGHT_RATIO,\n  onSnapPointChange,\n  className,\n  controls,\n  progress = { show: false, variant: 'fraction' },\n  stepKey,\n}: MobileDrawerProps) {\n  const { state } = useTour()\n  const viewportHeight = useViewportHeight()\n  const safeAreaBottom = useSafeAreaBottom()\n  const contentRef = React.useRef<HTMLDivElement>(null)\n  const contentHeight = useContentHeight(contentRef)\n\n  // Ensure minimized is available if allowMinimize\n  const snapPoints = React.useMemo(() => {\n    if (allowMinimize && !snapPointsProp.includes('minimized')) {\n      return ['minimized', ...snapPointsProp] as MobileDrawerSnapPoint[]\n    }\n    if (!allowMinimize) {\n      return snapPointsProp.filter((p) => p !== 'minimized')\n    }\n    return snapPointsProp\n  }, [snapPointsProp, allowMinimize])\n\n  const { heights, enabled, isMeasured } = useSnapPoints({\n    snapPoints,\n    viewportHeight,\n    safeAreaBottom,\n    contentHeight,\n    maxHeightRatio,\n  })\n\n  const [currentSnapPoint, setCurrentSnapPoint] =\n    React.useState<MobileDrawerSnapPoint>(defaultSnapPoint)\n  const [isDragging, setIsDragging] = React.useState(false)\n\n  const controls_ = useAnimationControls()\n\n  // Drawer has fixed height (expandedHeight)\n  // translateY pushes it down: 0 = expanded, (expanded - minimized) = minimized\n  const expandedHeight = heights['expanded']\n\n  // Calculate translateY for each snap point\n  const getTranslateY = React.useCallback(\n    (point: MobileDrawerSnapPoint) => {\n      const targetHeight = heights[point]\n      return expandedHeight - targetHeight\n    },\n    [heights, expandedHeight],\n  )\n\n  // Max drag = push down to minimized\n  const maxTranslateY = expandedHeight - MINIMIZED_HEIGHT\n\n  // Is minimized state\n  const isMinimized = currentSnapPoint === 'minimized'\n\n  // Animate to correct position when content is measured\n  const wasMeasuredRef = React.useRef(false)\n  React.useEffect(() => {\n    if (isMeasured && !wasMeasuredRef.current) {\n      wasMeasuredRef.current = true\n      // Smoothly animate to the correct height now that we know content size\n      const targetY = getTranslateY(currentSnapPoint)\n      controls_.start({ y: targetY }, springConfig)\n    }\n  }, [isMeasured, currentSnapPoint, getTranslateY, controls_])\n\n  // Content opacity: fade based on current translateY\n  const contentOpacity =\n    currentSnapPoint === 'minimized'\n      ? 0\n      : currentSnapPoint === 'peek'\n        ? 0.7\n        : 1\n\n  // Reset to expanded on step change\n  const stepIndex = state?.stepIndex\n  React.useEffect(() => {\n    if (stepIndex !== undefined) {\n      setCurrentSnapPoint('expanded')\n      controls_.start({ y: 0 }, springConfig)\n    }\n  }, [stepIndex, controls_])\n\n  // Snap to point\n  const snapTo = React.useCallback(\n    (point: MobileDrawerSnapPoint) => {\n      const targetY = getTranslateY(point)\n      setCurrentSnapPoint(point)\n      controls_.start({ y: targetY }, springConfig)\n      onSnapPointChange?.(point)\n    },\n    [getTranslateY, controls_, onSnapPointChange],\n  )\n\n  // Calculate nearest snap point based on drag position and velocity\n  const calculateSnapPoint = React.useCallback(\n    (currentY: number, velocity: number): MobileDrawerSnapPoint => {\n      // Project where we'll end up based on velocity\n      const projectedY = currentY + velocity * 0.15\n\n      // If fast swipe, go to direction\n      if (Math.abs(velocity) > VELOCITY_THRESHOLD) {\n        if (velocity > 0) {\n          // Swiping down -> go to next smaller height (larger Y)\n          const currentHeight = expandedHeight - currentY\n          const smaller = enabled.filter((s) => s.height < currentHeight)\n          return smaller.length > 0\n            ? smaller[smaller.length - 1].point\n            : currentSnapPoint\n        } else {\n          // Swiping up -> go to next larger height (smaller Y)\n          const currentHeight = expandedHeight - currentY\n          const larger = enabled.filter((s) => s.height > currentHeight)\n          return larger.length > 0 ? larger[0].point : currentSnapPoint\n        }\n      }\n\n      // Otherwise, find nearest snap point by Y position\n      let nearest = enabled[0]\n      let minDistance = Math.abs(projectedY - getTranslateY(nearest.point))\n\n      for (const snap of enabled) {\n        const snapY = getTranslateY(snap.point)\n        const distance = Math.abs(projectedY - snapY)\n        if (distance < minDistance) {\n          minDistance = distance\n          nearest = snap\n        }\n      }\n\n      return nearest.point\n    },\n    [enabled, expandedHeight, currentSnapPoint, getTranslateY],\n  )\n\n  const handleDragStart = () => {\n    setIsDragging(true)\n  }\n\n  const handleDragEnd = (_: unknown, info: PanInfo) => {\n    setIsDragging(false)\n    // Get current visual Y position from the animation\n    const element = document.querySelector('[data-mobile-drawer]') as HTMLElement\n    const transform = element?.style.transform || ''\n    const match = transform.match(/translateY\\(([^)]+)px\\)/)\n    const currentY = match ? parseFloat(match[1]) : getTranslateY(currentSnapPoint)\n\n    const targetPoint = calculateSnapPoint(currentY, info.velocity.y)\n    snapTo(targetPoint)\n  }\n\n  // Handle tap to toggle between minimized and expanded\n  const handleHandleTap = () => {\n    if (isMinimized) {\n      snapTo('expanded')\n    } else if (currentSnapPoint === 'expanded' && snapPoints.includes('peek')) {\n      snapTo('peek')\n    } else if (currentSnapPoint === 'peek') {\n      snapTo('expanded')\n    }\n  }\n\n  return (\n    <motion.div\n      className={cn(\n        'fixed inset-x-0 bottom-0 z-[2002]',\n        className,\n      )}\n      style={{\n        height: expandedHeight,\n        paddingBottom: `env(safe-area-inset-bottom, 0px)`,\n      }}\n      drag=\"y\"\n      dragConstraints={{ top: 0, bottom: maxTranslateY }}\n      dragElastic={DRAG_ELASTIC}\n      onDragStart={handleDragStart}\n      onDragEnd={handleDragEnd}\n      animate={controls_}\n      initial={{ y: getTranslateY(defaultSnapPoint) }}\n      data-mobile-drawer=\"\"\n      data-snap-point={currentSnapPoint}\n    >\n      <motion.div\n        className={cn(\n          'flex h-full flex-col overflow-hidden',\n          'rounded-t-[20px] border-t border-x',\n          'bg-popover text-popover-foreground',\n          'shadow-[0_-8px_32px_rgba(0,0,0,0.15)]',\n          'touch-none',\n        )}\n      >\n        {/* Drag handle */}\n        <div onClick={handleHandleTap} className=\"cursor-pointer\">\n          <MobileDrawerHandle isDragging={isDragging} />\n        </div>\n\n        {/* Minimized header - always visible */}\n        <div\n          className={cn(\n            'flex items-center justify-between px-4',\n            isMinimized ? 'pb-3' : 'pb-0',\n          )}\n        >\n          {progress.show && (\n            <TourProgress\n              variant={progress.variant ?? 'fraction'}\n              size={progress.size ?? 'sm'}\n              className={progress.className}\n            />\n          )}\n\n          {/* Aria live region for minimized state */}\n          {isMinimized && (\n            <span className=\"sr-only\" role=\"status\" aria-live=\"polite\">\n              Tour content minimized. Swipe up or tap to expand.\n            </span>\n          )}\n        </div>\n\n        {/* Content area - fades when minimized */}\n        <div\n          className=\"flex-1 overflow-y-auto overscroll-contain px-4 transition-opacity duration-200\"\n          style={{ opacity: contentOpacity }}\n          aria-hidden={isMinimized}\n        >\n          <AnimatePresence mode=\"wait\">\n            <motion.div\n              ref={contentRef}\n              key={stepKey}\n              initial={{ opacity: 0, y: 8 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: -8 }}\n              transition={{ duration: 0.25, ease: 'easeOut' }}\n            >\n              {children}\n            </motion.div>\n          </AnimatePresence>\n        </div>\n\n        {/* Controls - always visible */}\n        <div className=\"shrink-0\">\n          <TourControls {...controls} />\n        </div>\n      </motion.div>\n    </motion.div>\n  )\n}\n",
      "type": "registry:component"
    }
  ],
  "categories": [
    "tour",
    "mobile"
  ]
}